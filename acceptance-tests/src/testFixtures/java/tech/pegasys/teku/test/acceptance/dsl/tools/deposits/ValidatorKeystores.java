package tech.pegasys.teku.test.acceptance.dsl.tools.deposits;

import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;
import org.apache.commons.compress.utils.IOUtils;
import org.apache.commons.io.FileUtils;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

public class ValidatorKeystores {

  final List<ValidatorKeys> validatorKeys;

  final String KEYS_DIRECTORY_NAME = "keys";
  final String PASSWORDS_DIRECTORY_NAME = "passwords";
  final String VALIDATOR_KEYS_PASSWORD = "0xdeadbeef";

  Optional<File> maybeTarball = Optional.empty();

  public ValidatorKeystores(List<ValidatorKeys> validatorKeys) {
    this.validatorKeys = validatorKeys;
  }

  public File getTarball() throws Exception{
    return maybeTarball.orElseGet(() ->  {
      try {
        maybeTarball = Optional.of(createValidatorKeystoresTarBall());
        return maybeTarball.get();
      } catch (Exception e) {
        throw new IllegalStateException("Unable to create validator tarball");
      }
    });
  }

  public String getKeysDirectoryName() {
    return KEYS_DIRECTORY_NAME;
  }

  public String getPasswordsDirectoryName() {
    return PASSWORDS_DIRECTORY_NAME;
  }

  private File createValidatorKeystoresTarBall()
          throws Exception {
    final Path validatorInfoDirectoryPath = Path.of("./validatorInfo");
    final Path keysOutputPath = validatorInfoDirectoryPath.resolve(KEYS_DIRECTORY_NAME);
    final Path passwordsOutputPath = validatorInfoDirectoryPath.resolve(PASSWORDS_DIRECTORY_NAME);
    final ValidatorKeystoreGenerator keystoreGenerator =
            new ValidatorKeystoreGenerator(
                    VALIDATOR_KEYS_PASSWORD, keysOutputPath, passwordsOutputPath, (__) -> {});

    // create temporary tar file that can be copied into any docker container
    File validatorInfoTar = File.createTempFile("validatorInfo", ".tar");
    validatorInfoTar.deleteOnExit();

    // create keystores using the validator keys generated by deposit sender
    keystoreGenerator.generateKeystoreAndPasswordFiles(validatorKeys.stream().map(ValidatorKeys::getValidatorKey).collect(Collectors.toList()));

    // copy keystores directory to tar file and delete the now redundant directory
    copyDirectoryToTarFile(validatorInfoDirectoryPath, validatorInfoTar.toPath());
    FileUtils.deleteDirectory(validatorInfoDirectoryPath.toFile());
    return validatorInfoTar;
  }


  private static void copyDirectoryToTarFile(Path inputDirectoryPath, Path outputPath)
          throws IOException {
    File outputFile = outputPath.toFile();

    try (FileOutputStream fileOutputStream = new FileOutputStream(outputFile);
         BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(fileOutputStream);
         TarArchiveOutputStream tarArchiveOutputStream =
                 new TarArchiveOutputStream(bufferedOutputStream)) {

      tarArchiveOutputStream.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_POSIX);
      tarArchiveOutputStream.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);

      List<File> files =
              new ArrayList<>(
                      FileUtils.listFiles(inputDirectoryPath.toFile(), new String[] {"json", "txt"}, true));

      for (File currentFile : files) {
        String relativeFilePath =
                new File(inputDirectoryPath.toUri())
                        .toURI()
                        .relativize(new File(currentFile.getAbsolutePath()).toURI())
                        .getPath();

        TarArchiveEntry tarEntry = new TarArchiveEntry(currentFile, relativeFilePath);
        tarEntry.setSize(currentFile.length());

        tarArchiveOutputStream.putArchiveEntry(tarEntry);
        tarArchiveOutputStream.write(IOUtils.toByteArray(new FileInputStream(currentFile)));
        tarArchiveOutputStream.closeArchiveEntry();
      }
    }
  }
}
